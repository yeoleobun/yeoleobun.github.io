---
title: 偏序和并发
pubDatetime: 2024-10-7T10:54:00Z
featured: true
tags:
  - Java
---

## 偏序和严格偏序

集合 $S$ 上的偏序关系 $\le$ 是对于任意 $a,b,c \in S$，都满足：

* 自反性：$a \le a$
* 反对称性：如果 $a \le b$ 且 $b \le a$，则 $a = b$
* 传递性：如果 $a \le b$ 且 $b \le c$ 则 $a \le c$

严格偏序关系 $<$ 满足：
* 反自反性： $a \not < a$
* 反对称性：如果 $a < b$ 则 $ b \not < a$
* 传递性：如果 $a < b$ 且 $b < c$ 则 $a < c$

偏序和严格偏序的核心都在传递性，他们的差别仅仅是如何处理等于，接下来不做区分。

同样并发和并行的细微差别和内存模型也没有关系，也不做区分。

## 偏

偏序 (partial order) 中的偏是部分的意思。偏序就是部分有序，即可能存在 $a,b \in S$，$a \not < b$ 且 $b \not < a$。（注意定义中的如果）

相应的还有**全序**，即对于任意  $a,b \in S$，$a < b$ 或者 $a > b$。**在接下来关于全序的讨论中，注意讨论范围**。 

并发的核心就是部分有序。存在[竞争](https://en.wikipedia.org/wiki/Race_condition)的地方有序，其余的地方并行，才能在正确性和性能之间取得平衡。


## 环

把偏序集中元素当成顶点，关系当成边，构成一个有向无环图。（有自反性则有自环）

如果把反对称性去掉，则可以有环。但程序的运行顺序中出现环是反直觉的。

## 语法和语义

如果代码是语法，运行的结果就是语义。比如：

```java
a = 1
b = 2
c = a * b
```
如果调换 1,2 行的顺序，变量的求值并不会改变。

表达式之间的依赖关系是一个偏序关系。在上面的代码中变量 `c` 的求值依赖于变量 `a` 和 `b` 的求值，但 `a` 和 `b` 之间不存在依赖关系。

在单线程语义下，运行顺序是一个保持依赖关系的全序，或者说它是一个依赖关系的拓扑排序。

## 顺序

在线程 t 的所有线程间动作（读写共享变量）中，t 的**程序顺序**是一个全序，它反映了这些动作在单线程语义下可能发生的顺序。

如果一组动作的运行顺序是全序，且和程序顺序保持一致，称它是**顺序一致**的。就好像洗牌一样，在两叠牌交错以后，每一叠牌的顺序是保持不变的。

![洗牌](@assets/images/shuffle.jpg)

一个运行的**同步顺序**是所有同步动作（对 volatile 变量的读写）的一个全序。对于每个线程 t , t 中的同步动作在**同步顺序**中和在 t 的**程序顺序**中顺序保持一致。

对于 volatile 变量的写 **synchronized-with** 所有**后续**对该变量的读。（这里的后续指同步顺序中的后续）

对于两个动作 x 和 y，称 x happens-before y 当：

1. x 和 y 在同一个线程 t 中，且在 t 的程序顺序中 x 在 y 之前
2. x synchronized-with y
3. 如果 hb(x,y) 且 hb(y,z) 则 hb(x,z)

虽然这里没有关于反自反性的说明，但无论是单个线程的程序顺序，还是全体同步动作的同步顺序都是全序，假设有两个动作处于不同线程且成环，则环中一定有两个同步动作处于不同线程，这和全体同步动作是全序相矛盾。因此 happens-before 是一个偏序。

## 顺序一致性

1. 对于同一个变量的两个动作，如果至少有一个是写，则称这两个动作是**冲突**的。
2. 一个程序中有两个**冲突**的动作之间没有 happens-before 关系，则称它存在**数据竞争**。
3. 一个程序的所有**顺序一致**运行都没有**数据竞争**，则称它是**正确同步**的。
4. 一个程序如果是**正确同步**的，则它的所有运行是**顺序一致**的。

简单的说，一个程序如果用 happens-before 给出了不同线程中对相同变量的读写的顺序，这个程序的运行结果是符合直觉的。

## 因果

注意到上述命题 3 和 4 中有一处微妙的地方。3 的前提是**所有顺序一致运行**没有数据竞争，4 的结论是**所有运行**都顺序一致。这是一个避免循环论证的手段，但他有漏洞。

从整体上看 happens-before 给出了程序顺序和同步顺序的限制，但对于非 volatile 的跨线程读写只限制了在顺序运行中不能有数据竞争。于是有下面这一个反例：

[Out of thin air](https://docs.oracle.com/javase/specs/jls/se23/html/jls-17.html#jls-17.4.8-A)：

| Thread 1  | Thread 2 |
| ------------- | ------------- |
| r1 = x;  | r2 = y;  |
| if (r1 != 0) y = 1;  | if (r2 != 0) x = 1;  |

其中 x,y 的初始值都为 0，在顺序一致运行的情况下，`y = 1` 和 `x = 1` 都没有发生，因此没有跨线程的读写，更不存在数据竞争。按照上述命题，他是正确同步的，因此它在所有运行中都顺序一致。

```java
r1 = x;  // sees write of x = 1
y = 1;
r2 = y;  // sees write of y = 1
x = 1;
```

但是在这个运行中有环，因此它不是全序，更不是顺序一致的。

因此有 [Causality Requirements](https://docs.oracle.com/javase/specs/jls/se23/html/jls-17.html#jls-17.4.8)，其中的重点在：

6. For any read r in Ai - Ci-1, we have hbi(Wi(r), r)
7. For any read r in (Ci - Ci-1), we have Wi(r) in Ci-1 and W(r) in Ci-1

限制了一个良定义的运行必须保持 happens before 和 写读的顺序。整个过程类似于拓扑排序，一个动作依赖的动作（happens-before 和读对应的写）必须先与它提交。

但 Causality Requirements 似乎只是模型正确性的~~丑陋~~修补，在实践中是无关紧要的东西。